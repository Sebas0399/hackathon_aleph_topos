// üìã Storacha Client - Implementaci√≥n basada en documentaci√≥n oficial
// https://docs.storacha.network/how-to/upload/

import { create } from '@storacha/client'

// Estado global del cliente
let client = null
let initializationPromise = null
let loginPromise = null
// Evita reintentos autom√°ticos infinitos cuando el login tarda o no se confirma
let loginAttempted = false
// Guard para una sola subida activa a la vez
let activeUpload = null
const UPLOAD_TIMEOUT_MS = 2 * 60 * 1000 // 2 minutos

/**
 * ‚úÖ Inicializar cliente Storacha seg√∫n la documentaci√≥n oficial
 */
const initializeStorachaClient = async () => {
  // Si ya hay un cliente listo, devolverlo
  if (client) {
    return client
  }

  // Si ya hay una inicializaci√≥n en curso, esperar a que termine
  if (initializationPromise) {
    return await initializationPromise
  }

  // Crear nueva promesa de inicializaci√≥n (solo una vez)
  initializationPromise = initializeClient()
  return await initializationPromise
}

/**
 * üîß Funci√≥n interna de inicializaci√≥n
 */
const initializeClient = async () => {
  try {
    console.log('üöÄ Inicializando Storacha Client...')
    
    // Crear cliente (usa store persistente por defecto)
    client = await create()
    console.log('‚úÖ Cliente Storacha creado')

    // Configurar espacio seg√∫n email disponible
    await setupStorachaSpace(client)
    
    return client
    
  } catch (error) {
    console.error('‚ùå Error inicializando Storacha:', error)
    // Limpiar estado en caso de error
    client = null
    initializationPromise = null
    loginPromise = null
    throw new Error(`Fall√≥ inicializaci√≥n: ${error.message}`)
  }
}

/**
 * ‚öôÔ∏è Configurar espacio usando email o local seg√∫n disponibilidad
 */
const setupStorachaSpace = async (client) => {
  const email = import.meta.env.VITE_STORACHA_EMAIL
  const spaceDID = import.meta.env.VITE_STORACHA_SPACE_DID

  console.log('üìß Email config:', email || 'no configurado')
  console.log('üè† Space DID config:', spaceDID ? `${spaceDID.slice(0, 20)}...` : 'no configurado')

  // Opci√≥n 1: Usar espacio configurado si existe
  if (spaceDID && spaceDID !== 'your_space_did_here') {
    try {
      console.log('üéØ Intentando usar espacio configurado...')
      await client.setCurrentSpace(spaceDID)
      
      const currentSpace = client.currentSpace()
      if (currentSpace && currentSpace.did() === spaceDID) {
        console.log('‚úÖ Espacio configurado establecido')
        return currentSpace
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è No se pudo usar espacio configurado:', error.message)
    }
  }

  // Opci√≥n 2: Autenticaci√≥n con email (intento √∫nico autom√°tico)
  // Si el login o la confirmaci√≥n del plan tarda demasiado, hacemos fallback a espacio local
  const LOGIN_TIMEOUT_MS = 15000 // 15s
  const PLAN_TIMEOUT_MS = 15000 // 15s

  if (email && email !== 'tu_email_aqui' && !loginAttempted) {
    loginAttempted = true
    try {
      console.log('üì® Intentando login con email:', email)

      // Evitar m√∫ltiples logins simult√°neos del mismo email
      if (!loginPromise) {
        loginPromise = client.login(email)
      }

      // Esperamos el login pero con timeout para no dejar la app colgada
      const loginResult = await Promise.race([
        loginPromise,
        new Promise((_, reject) => setTimeout(() => reject(new Error('login_timeout')), LOGIN_TIMEOUT_MS))
      ])

      const account = loginResult
      console.log('‚úÖ Login exitoso')

      // Esperar confirmaci√≥n del plan de pago con timeout
      console.log('‚è≥ Esperando confirmaci√≥n del plan...')
      await Promise.race([
        account.plan.wait(),
        new Promise((_, reject) => setTimeout(() => reject(new Error('plan_timeout')), PLAN_TIMEOUT_MS))
      ])
      console.log('‚úÖ Plan confirmado')

      // Crear espacio con recovery
      const space = await client.createSpace('storacha-space', { account })
      console.log('‚úÖ Espacio creado con recovery:', space.did())

      // Establecer como actual
      await client.setCurrentSpace(space.did())

      console.log('üí° Guarda este DID para futuras sesiones:')
      console.log(`VITE_STORACHA_SPACE_DID=${space.did()}`)

      return space

    } catch (emailError) {
      console.warn('‚ö†Ô∏è Error con autenticaci√≥n por email:', emailError.message)
      // Limpiar loginPromise en caso de error o timeout para permitir reintentos manuales
      loginPromise = null

      if (emailError.message.includes('login_timeout') || emailError.message.includes('plan_timeout')) {
        console.warn('‚è≥ Timeout en login/plan ‚Äî se usar√° espacio local como fallback')
      } else if (emailError.message.includes('confirmation')) {
        console.log('üì¨ Revisa tu email para confirmar la cuenta')
      } else if (emailError.message.includes('plan')) {
        console.log('üí≥ Configura tu plan de pago en Storacha')
      }

      console.log('üîÑ Continuando con espacio local...')
    }
  }

  // Opci√≥n 3: Espacio local (sin recovery)
  console.log('üè† Creando espacio local...')
  const space = await client.createSpace('local-space')
  console.log('‚úÖ Espacio local creado:', space.did())
  console.log('‚ö†Ô∏è Sin recovery - solo para esta sesi√≥n')
  
  await client.setCurrentSpace(space.did())
  return space
}

/**
 * Crear un espacio local y establecerlo como current (fallback)
 */
const ensureLocalSpace = async (client) => {
  try {
    console.log('üè† Intentando crear espacio local (fallback)')
    const space = await client.createSpace('local-space-fallback')
    await client.setCurrentSpace(space.did())
    console.log('‚úÖ Espacio local fallback creado:', space.did())
    return space
  } catch (err) {
    console.warn('‚ö†Ô∏è No se pudo crear espacio local fallback:', err.message)
    throw err
  }
}

export { ensureLocalSpace }

/**
 * üìÅ Subir archivo √∫nico
 * Ref: https://docs.storacha.network/how-to/upload/#preparing-files-and-uploading
 */
export const uploadSingleFile = async (file) => {
  try {
    console.log('üì§ Subiendo archivo:', file.name)
    
    // Si ya hay una subida en curso, reutilizarla (evita m√∫ltiples peticiones por clicks duplicados)
    if (activeUpload) {
      console.log('üîÅ Esperando upload activo existente...')
      return await activeUpload
    }

    const client = await initializeStorachaClient()

    // Lanzar la subida y aplicar timeout
    const controller = typeof AbortController !== 'undefined' ? new AbortController() : null
    const uploadPromise = (async () => {
      try {
        // Intentar pasar signal si el cliente lo soporta
        if (controller) {
          try {
            const cid = await client.uploadFile(file, { signal: controller.signal })
            return cid.toString()
          } catch (err) {
            // Si el cliente no soporta signal, intentar sin opciones
            console.warn('‚ö†Ô∏è client.uploadFile no acept√≥ signal, reintentando sin signal:', err.message)
            const cid = await client.uploadFile(file)
            return cid.toString()
          }
        } else {
          const cid = await client.uploadFile(file)
          return cid.toString()
        }
      } catch (err) {
        throw err
      }
    })()

    activeUpload = (async () => {
      try {
        // Esperar la subida con timeout
        const result = await Promise.race([
          uploadPromise,
          new Promise((_, reject) => setTimeout(() => reject(new Error('upload_timeout')), UPLOAD_TIMEOUT_MS))
        ])
        console.log('‚úÖ Archivo subido con CID:', result)
        return result
      } catch (err) {
        // Si hay error de permisos del espacio, intentar crear espacio local y reintentar una vez
        if (err && err.message && err.message.includes('space/blob/add')) {
          console.warn('‚ùå Error de permisos space/blob/add detectado, intentando espacio local y reintento...')
          try {
            const space = await ensureLocalSpace(client)

            // Loguear el espacio actual para depuraci√≥n
            try {
              const current = client.currentSpace()
              console.log('‚ÑπÔ∏è Espacio actual tras fallback:', current && typeof current.did === 'function' ? current.did() : current)
            } catch (logErr) {
              console.warn('‚ö†Ô∏è No se pudo leer currentSpace():', logErr.message)
            }

            // Esperar un peque√±o lapso para que el servidor procese la creaci√≥n del espacio
            await new Promise((r) => setTimeout(r, 500))

            // Primer reintento
            try {
              const cidRetry = await client.uploadFile(file)
              console.log('üîÅ Reintento exitoso con CID:', cidRetry.toString())
              return cidRetry.toString()
            } catch (uploadErr) {
              console.warn('‚ö†Ô∏è Reintento 1 fall√≥:', uploadErr.message)

              // Intentar re-asignar el espacio actual y reintentar una vez m√°s
              try {
                await client.setCurrentSpace(space.did())
                // espera breve antes del segundo intento
                await new Promise((r) => setTimeout(r, 300))
                const cidRetry2 = await client.uploadFile(file)
                console.log('üîÅ Reintento 2 exitoso con CID:', cidRetry2.toString())
                return cidRetry2.toString()
              } catch (retryErr2) {
                console.error('‚ùå Reintento 2 fall√≥:', retryErr2.message)
                throw retryErr2
              }
            }
          } catch (retryErr) {
            console.error('‚ùå Reintento fall√≥:', retryErr.message)
            throw retryErr
          }
        }
        // En timeout o error, abortar la petici√≥n nativa si es posible
        if (err && err.message && err.message.includes('upload_timeout')) {
          console.warn('‚è≥ Upload timeout alcanzado, abortando fetch subyacente si es soportado')
          try {
            controller?.abort()
          } catch (abortErr) {
            console.warn('‚ö†Ô∏è Abort no soportado o fallo al abortar:', abortErr.message)
          }
        }
        throw err
      } finally {
        // Limpiar el guard cuando termine o falle
        activeUpload = null
      }
    })()

    return await activeUpload
    
  } catch (error) {
    console.error('‚ùå Error subiendo archivo:', error)
    throw new Error(`Fallo en subida: ${error.message}`)
  }
}

/**
 * üìÅ Subir m√∫ltiples archivos
 */
export const uploadMultipleFiles = async (files) => {
  try {
    console.log('üì§ Subiendo directorio con', files.length, 'archivos')
    
    const client = await initializeStorachaClient()
    const cid = await client.uploadDirectory(files)
    
    console.log('‚úÖ Directorio subido con CID:', cid.toString())
    return cid.toString()
    
  } catch (error) {
    console.error('‚ùå Error subiendo directorio:', error)
    throw new Error(`Fallo en subida: ${error.message}`)
  }
}

/**
 * üîÑ Legacy function para compatibilidad
 */
export const storeFile = async (file) => {
  return await uploadSingleFile(file)
}

/**
 * Recurso para debug: indica si hay una subida activa
 */
export const getActiveUploadCount = () => {
  return activeUpload ? 1 : 0
}

/**
 * ‚ÑπÔ∏è Obtener informaci√≥n del cliente
 */
export const getClientInfo = async () => {
  try {
    const client = await initializeStorachaClient()
    const space = client.currentSpace()
    
    return {
      isReady: !!client,
      hasSpace: !!space,
      spaceDID: space?.did(),
      agentDID: client.agent?.did()
    }
  } catch (error) {
    return {
      isReady: false,
      hasSpace: false,
      error: error.message
    }
  }
}

/**
 * üßπ Limpiar estado para testing
 */
export const resetClient = () => {
  client = null
  initializationPromise = null
  loginPromise = null
  console.log('üßπ Cliente reiniciado')
}
